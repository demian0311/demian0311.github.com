<p>Alright this isn’t much but I’m satisfied with myself and it surprisingly took me a
little bit to push the right buttons to make it work.</p>

<p>I use EasyMock in my unit tests in Java8.  Mocking frameworks will typically have a
recording phase and then a phase where your expectations should be ready to play back.
With EasyMock your unit test can extend <code>EasyMockSupport</code>.  That class gives you access
to methods like <code>replayAll()</code> and <code>verifyAll()</code>.</p>

<h2 id="before">Before</h2>

<p>``` java
@Test public void test() {
   // a bunch of expects</p>

<p>replayAll();
   Inter actual = ageFinder.findAge(user);
   verifyAll();</p>

<p>assertEquals(30, actual);
}
```</p>

<h2 id="after">After</h2>

<p>This isn’t as smooth as you’d see in Scala or Groovy but in Java8 you can do something like this.</p>

<p>``` java
public class MySupport extends EasyMockSupport {</p>

<pre><code>protected void withMocks(Runnable runnableIn) {
    replayAll();
    runnableIn.run();
    verifyAll();
}

protected &lt;T&gt;T withMocks(Supplier&lt;T&gt; supplierIn) {
    replayAll();
    T actual = supplierIn.get();
    verifyAll();

    return actual;
} } ``` I think I need both versions of `withMocks`.  The first one handles when you are testing a method that doesn't return anything and the second one handles when your method does return something.  One of the  things that gave me trouble was figuring out what interface in `java.util.function` would not  return any value.  Of course the answer is our old friend `Runnable`.  I also struggled with  what Java wanted for the generics, that stuff isn't obvious to me.
</code></pre>

<p>Then your test extends <code>MySupport</code>.  And within your tests you can have code that looks like this.</p>

<p><code>java
@Test public void test() {
   // a bunch of expects
   Integer actual = withMocks(() -&gt; ageFinder.findAge(user);
   assertEquals(30, actual);
}
</code></p>

<h2 id="caveat">Caveat</h2>

<p>This tightens up unit tests but I did run into a caveat that I should mention.  If the constructor for
your <em>class under test</em> uses mocks that would need to be between the <code>replayAll()</code> and <code>verifyAll()</code> 
methods then you might want to create a method in your test that instantiates your <em>class under test</em>.
It might look something like this.</p>

<p>``` java
private AgeFinder createAgeFinder() {
   return new AgeFinder(mockDatabase);
}</p>

<p>@Test public void test() {
   // a bunch of expects
   Integer actual = withMocks(() -&gt; createAgeFinder().findAge(user);
   assertEquals(30, actual);
}
```</p>
